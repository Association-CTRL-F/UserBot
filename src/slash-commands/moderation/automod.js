/* eslint-disable no-case-declarations */
/* eslint-disable default-case */
import { SlashCommandBuilder, ActionRowBuilder, SelectMenuBuilder, EmbedBuilder } from 'discord.js'
import { Pagination } from 'pagination.djs'
import { isGuildSetup } from '../../util/util.js'

export default {
	data: new SlashCommandBuilder()
		.setName('automod')
		.setDescription("G√®re l'Automod")
		.addSubcommandGroup(subcommandGroup =>
			subcommandGroup
				.setName('domains')
				.setDescription('G√®res les domaines blacklist√©s')
				.addSubcommand(subcommand =>
					subcommand.setName('view').setDescription("Voir les r√®gles d'Automod"),
				)
				.addSubcommand(subcommand =>
					subcommand
						.setName('add')
						.setDescription('Ajouter un domaine √† la blacklist')
						.addStringOption(option =>
							option.setName('domaine').setDescription('Domaine').setRequired(true),
						),
				)
				.addSubcommand(subcommand =>
					subcommand
						.setName('del')
						.setDescription('Supprimer un domaine de la blacklist')
						.addStringOption(option =>
							option.setName('domaine').setDescription('Domaine').setRequired(true),
						),
				),
		)
		.addSubcommandGroup(subcommandGroup =>
			subcommandGroup
				.setName('rules')
				.setDescription("G√®res les r√®gles d'Automod")
				.addSubcommand(subcommand =>
					subcommand
						.setName('view')
						.setDescription("Voir une r√®gle d'Automod")
						.addStringOption(option =>
							option.setName('id').setDescription('ID de la r√®gle'),
						),
				)
				.addSubcommand(subcommand =>
					subcommand.setName('create').setDescription("Cr√©er une r√®gle d'Automod"),
				)
				.addSubcommand(subcommand =>
					subcommand.setName('edit').setDescription("Modifier une r√®gle d'Automod"),
				)
				.addSubcommand(subcommand =>
					subcommand.setName('del').setDescription("Supprimer une r√®gle d'Automod"),
				),
		),
	interaction: async (interaction, client) => {
		// V√©rification que la guild soit enti√®rement setup
		const isSetup = await isGuildSetup(interaction.guild, client)

		if (!isSetup)
			return interaction.reply({
				content: "Le serveur n'est pas enti√®rement configur√© üòï",
				ephemeral: true,
			})

		// Acquisition de la base de donn√©es
		const bdd = client.config.db.pools.userbot
		if (!bdd)
			return interaction.reply({
				content: 'Une erreur est survenue lors de la connexion √† la base de donn√©es üòï',
				ephemeral: true,
			})

		// Acquisition du domaine √† ajouter
		const domainString = interaction.options.getString('domaine')

		// V√©rification si le domaine existe
		let domainBdd = {}
		try {
			const sqlCheckName = 'SELECT * FROM automod_domains WHERE domain = ? AND guildId = ?'
			const dataCheckName = [domainString, interaction.guild.id]
			const [resultCheckName] = await bdd.execute(sqlCheckName, dataCheckName)
			domainBdd = resultCheckName[0]
		} catch (error) {
			return interaction.reply({
				content:
					'Une erreur est survenue lors de la r√©cup√©ration de la commande en base de donn√©es üòï',
				ephemeral: true,
			})
		}

		switch (interaction.options.getSubcommandGroup()) {
			// R√®gles d'automod
			case 'rules':
				// R√©cup√©ration des r√®gles
				let rules = []
				try {
					const sqlSelect = 'SELECT * FROM automod_rules WHERE guildId = ?'
					const dataSelect = [interaction.guild.id]
					const [resultSelect] = await bdd.execute(sqlSelect, dataSelect)
					rules = resultSelect
				} catch {
					return interaction.reply({
						content:
							"Une erreur est survenue lors de la r√©cup√©ration des r√®gles d'Automod üò¨",
						ephemeral: true,
					})
				}

				if (rules.length === 0 && interaction.options.getSubcommand() !== 'create')
					return interaction.reply({
						content: "Aucune r√®gle n'a √©t√© cr√©√©e üòï",
						ephemeral: true,
					})

				const arrayRules = []
				rules.forEach(rule => {
					arrayRules.push({
						label: rule.customId,
						description: `Modification de la r√®gle "${rule.customId}"`,
						value: rule.customId,
					})
				})

				switch (interaction.options.getSubcommand()) {
					// Voir les r√®gles d'automod
					case 'view':
						// Acquisition du nom
						const ruleId = interaction.options.getString('id')

						// V√©rification si la r√®gle existe
						let ruleBdd = {}
						try {
							const sqlCheckName =
								'SELECT * FROM automod_rules WHERE id = ? AND guildId = ?'
							const dataCheckName = [ruleId, interaction.guild.id]
							const [resultCheckName] = await bdd.execute(sqlCheckName, dataCheckName)
							ruleBdd = resultCheckName[0]
						} catch (error) {
							return interaction.reply({
								content:
									'Une erreur est survenue lors de la r√©cup√©ration de la commande en base de donn√©es üòï',
								ephemeral: true,
							})
						}

						if (ruleId) {
							// V√©rification que la commande existe bien
							if (!ruleBdd)
								return interaction.reply({
									content: `La r√®gle n'existe pas üòï`,
									ephemeral: true,
								})

							let displayRoles = ''
							const ignoredRoles = ruleBdd.ignoredRoles.split(',')
							ignoredRoles.forEach(ignoredRole => {
								displayRoles = displayRoles.concat('\n', `‚Ä¢ <@&${ignoredRole}>`)
							})

							const embed = new EmbedBuilder()
								.setColor('C27C0E')
								.setTitle(`R√®gle d'automod "${ruleBdd.customId}"`)
								.addFields([
									{
										name: 'Type',
										value: ruleBdd.type,
									},
									{
										name: 'Contenu de la regex',
										value: `\`\`\`${ruleBdd.regex}\`\`\``,
									},
									{
										name: 'R√¥les ignor√©s',
										value: displayRoles,
									},
									{
										name: 'Raison',
										value: ruleBdd.reason,
									},
								])

							return interaction.reply({ embeds: [embed] })
						}

						// Sinon, boucle d'ajout des champs
						const fieldsEmbed = []
						rules.forEach(rule => {
							fieldsEmbed.push({
								name: `R√®gle #${rule.id}`,
								value: rule.customId,
							})
						})

						// Configuration de l'embed
						const pagination = new Pagination(interaction, {
							firstEmoji: '‚èÆ',
							prevEmoji: '‚óÄÔ∏è',
							nextEmoji: '‚ñ∂Ô∏è',
							lastEmoji: '‚è≠',
							limit: 5,
							idle: 120000,
							ephemeral: false,
							prevDescription: '',
							postDescription: '',
							buttonStyle: 'Secondary',
							loop: false,
						})

						pagination.setTitle("R√®gles d'automod")
						pagination.setDescription(`**Total : ${rules.length}**`)
						pagination.setColor('#C27C0E')
						pagination.setFields(fieldsEmbed)
						pagination.footer = { text: 'Page : {pageNumber} / {totalPages}' }
						pagination.paginateFields(true)

						// Envoi de l'embed
						return pagination.render()

					// Cr√©er une r√®gle d'automod
					case 'create':
						const menuType = new ActionRowBuilder().addComponents(
							new SelectMenuBuilder()
								.setCustomId('select-rule-create')
								.setPlaceholder('S√©lectionnez un type de r√®gle')
								.addOptions([
									{
										label: 'Warn',
										description: 'Avertir le membre',
										value: 'warn',
									},
									{
										label: 'Ban',
										description: 'banir le membre',
										value: 'ban',
									},
								]),
						)

						return interaction.reply({
							content: 'Choisissez le type de r√®gle √† cr√©er',
							components: [menuType],
							ephemeral: true,
						})

					// Modifier une r√®gle d'automod
					case 'edit':
						const menuRulesEdit = new ActionRowBuilder().addComponents(
							new SelectMenuBuilder()
								.setCustomId('select-rule-edit')
								.setPlaceholder('S√©lectionnez la r√®gle')
								.addOptions(arrayRules),
						)

						return interaction.reply({
							content: 'Choisissez la r√®gle √† modifier',
							components: [menuRulesEdit],
							ephemeral: true,
						})

					// Supprimer une r√®gle d'automod
					case 'del':
						const menuRulesDel = new ActionRowBuilder().addComponents(
							new SelectMenuBuilder()
								.setCustomId('select-rule-del')
								.setPlaceholder('S√©lectionnez la r√®gle')
								.addOptions(arrayRules),
						)

						return interaction.reply({
							content: 'Choisissez la r√®gle √† supprimer',
							components: [menuRulesDel],
							ephemeral: true,
						})
				}
				break

			// Domaines blacklist√©s
			case 'domains':
				switch (interaction.options.getSubcommand()) {
					// Liste des domaines blacklist√©s
					case 'view':
						let domainsView = []
						try {
							const sqlCheckName = 'SELECT * FROM automod_domains WHERE guildId = ?'
							const dataCheckName = [interaction.guild.id]
							const [resultCheckName] = await bdd.execute(sqlCheckName, dataCheckName)
							domainsView = resultCheckName
						} catch (error) {
							return interaction.reply({
								content:
									'Une erreur est survenue lors de la r√©cup√©ration des domaines üòï',
								ephemeral: true,
							})
						}

						if (domainsView.length === 0)
							return interaction.reply({
								content: "Aucun domaine n'a √©t√© ajout√© üòï",
								ephemeral: true,
							})

						// Boucle d'ajout des champs
						const fieldsEmbedView = []

						domainsView.forEach(domain => {
							fieldsEmbedView.push({
								name: `Domaine #${domain.id}`,
								value: domain.domain,
							})
						})

						// Configuration de l'embed
						const paginationView = new Pagination(interaction, {
							firstEmoji: '‚èÆ',
							prevEmoji: '‚óÄÔ∏è',
							nextEmoji: '‚ñ∂Ô∏è',
							lastEmoji: '‚è≠',
							limit: 5,
							idle: 120000,
							ephemeral: false,
							prevDescription: '',
							postDescription: '',
							buttonStyle: 'Secondary',
							loop: false,
						})

						paginationView.setTitle('Domaines blacklist√©s')
						paginationView.setDescription(`**Total : ${domainsView.length}**`)
						paginationView.setColor('#C27C0E')
						paginationView.setFields(fieldsEmbedView)
						paginationView.footer = { text: 'Page : {pageNumber} / {totalPages}' }
						paginationView.paginateFields(true)

						// Envoi de l'embed
						return paginationView.render()

					// Ajouter un domaine blacklist√©
					case 'add':
						// V√©rification que le domaine existe bien
						if (domainBdd)
							return interaction.reply({
								content: `Le domaine **${domainString}** est d√©j√† ajout√© üòï`,
								ephemeral: true,
							})

						// Ajout du domaine en base de donn√©es
						try {
							const sqlInsert =
								'INSERT INTO automod_domains (guildId, domain) VALUES (?, ?)'
							const dataInsert = [interaction.guild.id, domainString]

							await bdd.execute(sqlInsert, dataInsert)
						} catch (error) {
							return interaction.reply({
								content:
									"Une erreur est survenue lors de la cr√©ation de l'ajout du domaine en base de donn√©es üòï",
								ephemeral: true,
							})
						}

						return interaction.reply({
							content: `Le domaine **${domainString}** a bien √©t√© ajout√© üëå`,
						})

					// Supprimer un domaine blacklist√©
					case 'del':
						// V√©rification que le domaine existe bien
						if (!domainBdd)
							return interaction.reply({
								content: `Le domaine **${domainString}** n'est pas ajout√© üòï`,
								ephemeral: true,
							})

						// Si oui, alors suppression du domaine
						// en base de donn√©es
						try {
							const sqlDelete =
								'DELETE FROM automod_domains WHERE domain = ? AND guildId = ?'
							const dataDelete = [domainString, interaction.guild.id]

							await bdd.execute(sqlDelete, dataDelete)
						} catch {
							return interaction.reply({
								content:
									'Une erreur est survenue lors de la suppression du domaine en base de donn√©es üò¨',
								ephemeral: true,
							})
						}

						return interaction.reply({
							content: `Le domaine **${domainString}** a bien √©t√© supprim√© üëå`,
						})
				}
		}
	},
}

/* eslint-disable default-case */
/* eslint-disable no-case-declarations */
import { SlashCommandBuilder } from '@discordjs/builders'
import { Constants, GuildMember } from 'discord.js'

export default {
	data: new SlashCommandBuilder()
		.setName('unmute')
		.setDescription('Unmute un membre')
		.addSubcommand(subcommand =>
			subcommand
				.setName('member')
				.setDescription('Mute un membre')
				.addUserOption(option =>
					option.setName('membre').setDescription('Membre').setRequired(true),
				),
		)
		.addSubcommand(subcommand =>
			subcommand
				.setName('members')
				.setDescription('Unmute des membres')
				.addStringOption(option =>
					option.setName('membres').setDescription('Membres').setRequired(true),
				),
		),
	interaction: async (interaction, client) => {
		// Acquisition du r√¥le muted
		const mutedRole = client.config.guild.roles.mutedRoleID
		if (!mutedRole)
			return interaction.reply({
				content: "Il n'y a pas de r√¥le Muted üòï",
				ephemeral: true,
			})

		// Acquisition de la base de donn√©es
		const bdd = client.config.db.pools.userbot
		if (!bdd)
			return interaction.reply({
				content: 'Une erreur est survenue lors de la connexion √† la base de donn√©es üòï',
				ephemeral: true,
			})

		// Acquisition du message d'unmute
		let unmuteDM = ''
		try {
			const sqlSelectUnmute = 'SELECT * FROM forms WHERE name = ?'
			const dataSelectUnmute = ['unmute']
			const [resultSelectUnmute] = await bdd.execute(sqlSelectUnmute, dataSelectUnmute)

			unmuteDM = resultSelectUnmute[0].content
		} catch (error) {
			console.error(error)
			return interaction.reply({
				content:
					"Une erreur est survenue lors de la r√©cup√©ration du message d'unmute en base de donn√©es üò¨",
				ephemeral: true,
			})
		}

		switch (interaction.options.getSubcommand()) {
			case 'member':
				// Acquisition du membre
				const user = interaction.options.getUser('membre')
				const member = interaction.guild.members.cache.get(user.id)
				if (!member)
					return interaction.reply({
						content:
							"Je n'ai pas trouv√© cet utilisateur, v√©rifie la mention ou l'ID üòï",
						ephemeral: true,
					})

				// V√©rification si le membre a bien le r√¥le muted
				if (!member.roles.cache.has(mutedRole))
					return interaction.reply({
						content: "Le membre n'est pas mut√© üòï",
						ephemeral: true,
					})

				// On ne peut pas se d√©mute soi-m√™me
				if (member.id === interaction.user.id)
					return interaction.reply({
						content: 'Tu ne peux pas te d√©mute toi-m√™me üòï',
						ephemeral: true,
					})

				// Envoi du message d'unmute en message priv√©
				const DMMessage = await member
					.send({
						embeds: [
							{
								color: '#C27C0E',
								title: 'Mute termin√©',
								description: unmuteDM,
								author: {
									name: interaction.guild.name,
									icon_url: interaction.guild.iconURL({ dynamic: true }),
									url: interaction.guild.vanityURL,
								},
							},
						],
					})
					.catch(error => {
						console.error(error)
					})

				// V√©rification si d√©j√† mute en base de donn√©es
				let mutedMember = {}
				try {
					const sqlCheck = 'SELECT * FROM mute WHERE discordID = ?'
					const dataCheck = [member.id]
					const [resultCheck] = await bdd.execute(sqlCheck, dataCheck)

					mutedMember = resultCheck[0]
				} catch (error) {
					console.error(error)
					return interaction.reply({
						content:
							'Une erreur est survenue lors de la lev√© du mute du membre en base de donn√©es üò¨',
						ephemeral: true,
					})
				}

				// Si oui alors on l√®ve le mute en base de donn√©es
				if (mutedMember) {
					try {
						const sqlDelete = 'DELETE FROM mute WHERE discordID = ?'
						const dataDelete = [member.id]
						await bdd.execute(sqlDelete, dataDelete)
					} catch {
						if (DMMessage) DMMessage.delete()
						return interaction.reply({
							content:
								'Une erreur est survenue lors de la lev√©e du mute du membre en base de donn√©es üò¨',
							ephemeral: true,
						})
					}

					// Action d'unmute du membre
					const unmuteAction = await member.roles.remove(mutedRole).catch(error => {
						// Suppression du message priv√© envoy√©
						// car action de mute non r√©alis√©e
						if (DMMessage) DMMessage.delete()

						// R√©insertion du mute en base de donn√©es
						try {
							const sql =
								'INSERT INTO mute (discordID, timestampStart, timestampEnd) VALUES (?, ?, ?)'
							const data = [
								mutedMember.discordID,
								mutedMember.timestampStart,
								mutedMember.timestampEnd,
							]

							bdd.execute(sql, data)
						} catch {
							return interaction.reply({
								content:
									'Une erreur est survenue lors de la lev√©e du mute du membre üò¨',
								ephemeral: true,
							})
						}

						if (error.code === Constants.APIErrors.MISSING_PERMISSIONS)
							return interaction.reply({
								content: "Je n'ai pas les permissions pour unmute ce membre üò¨",
								ephemeral: true,
							})

						console.error(error)
						return interaction.reply({
							content:
								'Une erreur est survenue lors de la lev√©e du mute du membre üò¨',
							ephemeral: true,
						})
					})

					// Si pas d'erreur, message de confirmation de l'unmute
					if (unmuteAction instanceof GuildMember)
						return interaction.reply({
							content: `üîä \`${member.user.tag}\` est d√©mut√©`,
						})

					// Si au moins une erreur, throw
					if (unmuteAction instanceof Error || DMMessage instanceof Error)
						throw new Error(
							"L'envoi d'un message et / ou l'unmute d'un membre a √©chou√©. Voir les logs pr√©c√©dents pour plus d'informations.",
						)
				}

				// Action d'unmute du membre
				const unmuteAction = await member.roles.remove(mutedRole).catch(error => {
					// Suppression du message priv√© envoy√©
					// car action de mute non r√©alis√©e
					if (DMMessage) DMMessage.delete()

					if (error.code === Constants.APIErrors.MISSING_PERMISSIONS)
						return interaction.reply({
							content: "Je n'ai pas les permissions pour unmute ce membre üò¨",
							ephemeral: true,
						})

					console.error(error)
					return interaction.reply({
						content: 'Une erreur est survenue lors de la lev√©e du mute du membre üò¨',
						ephemeral: true,
					})
				})

				// Si pas d'erreur, message de confirmation de l'unmute
				if (unmuteAction instanceof GuildMember)
					return interaction.reply({
						content: `\`${member.user.tag}\` n'est pas mut√© en base de donn√©es, mais le r√¥le a √©t√© retir√© üò¨`,
					})

				// Si au moins une erreur, throw
				if (unmuteAction instanceof Error || DMMessage instanceof Error)
					throw new Error(
						"L'envoi d'un message et / ou l'unmute d'un membre a √©chou√©. Voir les logs pr√©c√©dents pour plus d'informations.",
					)

				return

			case 'members':
				// Acquisition des membres
				const users = interaction.options.getString('membres')
				const usersArray = users.split(',')
				let unmuteMessage = ''

				await Promise.all(
					usersArray.map(async userGroup => {
						// Acquisition du membre
						const memberGroup = await interaction.guild.members.fetch(userGroup)
						if (!memberGroup) return

						// V√©rification si le membre a d√©j√† le r√¥le muted
						if (!memberGroup.roles.cache.has(mutedRole)) return

						// On ne peut pas se mute soi-m√™me
						// if (memberGroup.id === interaction.user.id)
						// 	return interaction.reply({
						// 		content: "Tu ne peux pas t'unmute toi-m√™me üòï",
						// 		ephemeral: true,
						// 	})

						// Envoi du message d'unmute en message priv√©
						const DMMessageGroup = await memberGroup
							.send({
								embeds: [
									{
										color: '#C27C0E',
										title: 'Mute termin√©',
										description: unmuteDM,
										author: {
											name: interaction.guild.name,
											icon_url: interaction.guild.iconURL({ dynamic: true }),
											url: interaction.guild.vanityURL,
										},
									},
								],
							})
							.catch(error => {
								console.error(error)
							})

						// V√©rification si d√©j√† mute en base de donn√©es
						let mutedGroup = {}
						try {
							const sqlCheck = 'SELECT * FROM mute WHERE discordID = ?'
							const dataCheck = [memberGroup.id]
							const [resultCheck] = await bdd.execute(sqlCheck, dataCheck)
							mutedGroup = resultCheck[0]
						} catch {
							if (DMMessageGroup) DMMessageGroup.delete()
							return interaction.reply({
								content:
									"Une erreur est survenue lors de l'unmute du membre en base de donn√©es üò¨",
								ephemeral: true,
							})
						}

						// Si oui alors on l√®ve le mute en base de donn√©es
						if (mutedGroup) {
							try {
								const sqlDelete = 'DELETE FROM mute WHERE discordID = ?'
								const dataDelete = [memberGroup.id]
								await bdd.execute(sqlDelete, dataDelete)
							} catch {
								if (DMMessageGroup) DMMessageGroup.delete()
								return interaction.reply({
									content:
										"Une erreur est survenue lors de l'unmute du membre en base de donn√©es üò¨",
									ephemeral: true,
								})
							}

							// Action d'unmute du membre
							const unmuteActionGroup = await memberGroup.roles
								.remove(mutedRole)
								.catch(error => {
									// Suppression du message priv√© envoy√©
									// car action de mute non r√©alis√©e
									if (DMMessageGroup) DMMessageGroup.delete()

									// R√©insertion du mute en base de donn√©es
									try {
										const sql =
											'INSERT INTO mute (discordID, timestampStart, timestampEnd) VALUES (?, ?, ?)'
										const data = [
											mutedGroup.discordID,
											mutedGroup.timestampStart,
											mutedGroup.timestampEnd,
										]

										bdd.execute(sql, data)
									} catch {
										return interaction.reply({
											content:
												'Une erreur est survenue lors de la lev√©e du mute du membre üò¨',
											ephemeral: true,
										})
									}

									if (error.code === Constants.APIErrors.MISSING_PERMISSIONS)
										return interaction.reply({
											content:
												"Je n'ai pas les permissions pour unmute ce membre üò¨",
											ephemeral: true,
										})

									console.error(error)
									return interaction.reply({
										content:
											'Une erreur est survenue lors de la lev√©e du mute du membre üò¨',
										ephemeral: true,
									})
								})

							// Si pas d'erreur,
							// message de confirmation de l'unmute
							if (unmuteActionGroup instanceof GuildMember)
								unmuteMessage = unmuteMessage.concat(
									' ',
									`\`${memberGroup.user.tag}\`,`,
								)

							// Si au moins une erreur, throw
							if (
								unmuteActionGroup instanceof Error ||
								DMMessageGroup instanceof Error
							)
								throw new Error(
									"L'envoi d'un message et / ou l'unmute d'un membre a √©chou√©. Voir les logs pr√©c√©dents pour plus d'informations.",
								)
						}

						// Action d'unmute du membre
						const unmuteActionGroup = await memberGroup.roles
							.remove(mutedRole)
							.catch(error => {
								// Suppression du message priv√© envoy√©
								// car action de mute non r√©alis√©e
								if (DMMessageGroup) DMMessageGroup.delete()

								if (error.code === Constants.APIErrors.MISSING_PERMISSIONS)
									return interaction.reply({
										content:
											"Je n'ai pas les permissions pour unmute ce membre üò¨",
										ephemeral: true,
									})

								console.error(error)
								return interaction.reply({
									content:
										'Une erreur est survenue lors de la lev√©e du mute du membre üò¨',
									ephemeral: true,
								})
							})

						// Si pas d'erreur, message de confirmation de l'unmute
						if (unmuteActionGroup instanceof GuildMember)
							unmuteMessage = unmuteMessage.concat(
								' ',
								`\`${memberGroup.user.tag}\`,`,
							)

						// Si au moins une erreur, throw
						if (unmuteActionGroup instanceof Error || DMMessageGroup instanceof Error)
							throw new Error(
								"L'envoi d'un message et / ou l'unmute d'un membre a √©chou√©. Voir les logs pr√©c√©dents pour plus d'informations.",
							)
					}),
				)

				// Si pas d'erreur, message de confirmation du mute
				if (unmuteMessage !== '')
					return interaction.reply({
						content: `üîä ${unmuteMessage} sont d√©mut√©s`,
					})

				return interaction.reply({
					content: `üîä Les membres sont d√©mut√©s`,
				})
		}
	},
}
